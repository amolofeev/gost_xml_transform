# pylint: disable=C0116,C0115,C0114,R0402
from io import BytesIO
from typing import Optional, Tuple

import lxml.etree as etree


class GOSTXMLTransform:
    def __init__(self, element: etree.Element):
        self.root = XMLNode(element)

    def to_bytes(self) -> bytes:
        """
        Build end return result bytes of transformed xml
        """
        with BytesIO() as fp:
            self.root.to_bytes(fp)
            return fp.getvalue()

    @classmethod
    def from_bytes(cls, xml_bytes: bytes) -> 'GOSTXMLTransform':
        """Initialise from bytes"""
        return GOSTXMLTransform(
            etree.fromstring(
                etree.tostring(
                    etree.fromstring(xml_bytes),
                    method='c14n', exclusive=True, with_comments=False
                )
            )
        )

    @classmethod
    def from_string(cls, xml_string: str, encoding: str = 'utf-8') -> 'GOSTXMLTransform':
        """Initialise from string"""
        return GOSTXMLTransform.from_bytes(xml_string.encode(encoding))


class XMLNode:
    def __init__(self, element: etree.Element, parent: 'XMLNode' = None):
        self.parent = parent
        self.generator = iter(range(1, 100000)) if parent is None else None
        self.element = element
        self.tag = etree.QName(element)
        self.text = element.text if element.text and element.text.strip() else ''
        self.qname = etree.QName(element.tag)
        self.nsmap: dict = {}
        self.attrib: list = []
        self.prefix: Optional[str] = None
        self._parse_nsmap()
        self._parse_attrib()
        self.children: Tuple['XMLNode', ...] = tuple(
            XMLNode(child, self)
            for child in self.element.iterchildren()
        )

    def to_bytes(self, fp: BytesIO):
        fp.write(
            f'<{self.prefix + ":" if self.prefix else ""}{self.tag.localname}'
            .encode('utf-8')
        )
        fp.write(self._nsmap_to_string().encode('utf-8'))
        fp.write(self._attrib_to_string().encode('utf-8'))
        fp.write(b'>')
        fp.write(self.text.encode('utf-8'))
        for child in self.children:
            child.to_bytes(fp)
        fp.write(
            f'</{self.prefix + ":" if self.prefix else ""}{self.tag.localname}>'
            .encode('utf-8')
        )

    def _parse_attrib(self) -> None:
        """
        Prepare and sort element.attrib to convert them to string
        result is list of tuples:
        if qualified form:
            (uri, name, value, uri - it'll be replaced to autogenerated ns prefix)
        if qualified form:
            ("~", name, value, None)
        """
        attrib_list = []
        for name, value in self.element.attrib.items():
            qname = etree.QName(name)
            attrib_list.append(
                [qname.namespace or '~', qname.localname, value, qname.namespace]
            )
        attrib_list = sorted(attrib_list, key=lambda x: x[:2])
        self.attrib = [
            [*attr[:3], self.get_ns(attr[0]) if attr[-1] else None]
            for attr in attrib_list
        ]

    def _get_next_id(self):
        """
        Get next sequence value.
        Sequence must be defined in the root element only
        """
        if not self.generator:
            return self.parent.next_id
        return next(self.generator)

    next_id = property(fget=_get_next_id)

    def _parse_nsmap(self) -> None:
        """
        - remove unused namespace
        - sort rest of them
        - replace to autogenerated ns prefix
        """
        self.prefix = self.get_ns(self.tag.namespace)

        # pylint: disable=W0125
        ns_from_attrib = {
            (etree.QName(attrib).namespace, etree.QName(attrib).localname)
            for attrib in self.element.attrib.keys()
            if etree.QName(attrib).namespace
        }

        for uri, _ in sorted(ns_from_attrib, key=lambda x: (x[0], x[1])):
            if uri is not None:
                self.get_ns(uri)

    def get_ns(self, uri, is_child=False) -> Optional[str]:
        """Try to find registered ns prefix or generate new one"""
        if uri in self.nsmap:
            return self.nsmap[uri]

        if self.parent:
            ns_prefix = self.parent.get_ns(uri, True)
            if ns_prefix is None:
                if is_child:
                    return None
                return self._register_ns_prfix(uri)
            return ns_prefix
        if not is_child:
            return self._register_ns_prfix(uri) if uri else ''
        return None

    def _register_ns_prfix(self, uri) -> str:
        """Register autogenerated ns prefix"""
        ns_prefix = f'ns{self._get_next_id()}'
        self.nsmap[uri] = ns_prefix
        return ns_prefix

    def _nsmap_to_string(self) -> str:
        """
        Return string of sorted namespace prefixes
        """
        if not self.nsmap:
            return ''

        namespace = etree.QName(self.element.tag).namespace

        nsmap = []

        if namespace in self.nsmap:
            nsmap.append(f'xmlns:{self.prefix}="{namespace}"')

        for uri, ns_prefix in sorted(self.nsmap.items(), key=lambda x: x[0]):
            if uri != namespace:
                nsmap.append(f'xmlns:{ns_prefix}="{uri}"')
        return ' ' + ' '.join(nsmap)

    def _attrib_to_string(self) -> str:
        """
        Return string of sorted attributes
        """
        if not self.attrib:
            return ''
        result = []
        for attr in self.attrib:
            if attr[-1] is None:
                string = f'{attr[1]}="{attr[-2]}"'
            else:
                string = f'{attr[-1]}:{attr[1]}="{attr[-2]}"'
            result.append(string)
        return ' ' + ' '.join(result)
